# -*- coding: utf-8 -*-
"""EARIN_Exercise2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HFWg9mDyvTnluCWWUWL5nkgRA1BhfyIu

# **EARIN EXERICISE #2**  
[*Deininger Johannes, Sasikumar Kolamannathodiyil Hari Shankar*]

## Solution
"""

import numpy as np
import random as rand
import matplotlib.pyplot as plt

def getfunc():
    print("Welcome to our genetic Alogrithm!")
    print("Please enter c (scalar)")
    c = float(input())
    print("Please enter verctor b, separated by blank")
    arr = (input())  # takes the whole line of n numbers
    b = np.array([list(map(int, arr.split(' ')))]).T
    print(b)    
    size = len(b)
    print("Please enter the function parameter A (Matrix, ", size,"x", size,") separated by return")
    A = []
            # For user input
    for i in range(size):  # A for loop for row entries
      g = []
      for r in range(size):  # A for loop for column entries
        g.append(int(input()))
      A.append(g)
    A = np.array(A)
    print(A)
    
    return A,b,c

def getAlgoParam():
    print("Please enter the Range of the Problem in #-of-bits:")
    ran = int(input())
    print("Please enter Population size:")
    pop_size = int(input())
    print("Please enter crossover Probability:")
    run = 1
    cross_prob = 0
    while run:
      cross_prob = float(input())
      print(cross_prob)
      if cross_prob <=1 and cross_prob >0:
        run = 0
      else:
        print("No meaningful Crossover probability, reenter a value between 0 and 1")
    print("Please enter Mutation Probability:")
    run = 1
    mut_prob = 0
    while run:
      mut_prob = float(input())
      print(mut_prob)
      if mut_prob <=1 and mut_prob >0:
        run = 0
      else:
        print("No meaningful Mutation probability, reenter a value between 0 and 1")
    print("Please enter number of iterations of the algorithm:")
    iterations = 0 
    run = 1
    while run:
      iterations = int(input())
      if iterations >=1:
        run = 0
      else:
        print("No meaningful number of iterations, reenter a positive integer")
        
    return pop_size, cross_prob, mut_prob, iterations, ran

def target(A,b,c,x):
    return np.array(np.matmul(np.transpose(x), np.matmul(A,x)) + np.matmul(np.transpose(b), x) + c).item()

def popFitness(pop):
  F = []
  for i in range(pop.shape[0]):
    x = np.array([pop[i][:]]).T
    F.append(target(A,b,c,x))
  return F

def roulette(pop, reqItems):
    J = np.array(popFitness(pop)) #Value of Target function of each genom
    J = (J - min(J)) / (max(J) - min(J))   # scaling
    S = sum(J)
    reqIdx = []
    for i in range(reqItems):
      P = rand.uniform(0, S)
      j = -1
      T = 0
      while T < P:
        T = T + J[j]
        j = j+1
      reqIdx.append(j)
    return reqIdx   # Index of population (-> One genome), which shall be parent

def int2binarr(int_val, bits):
  one_bits = 2**bits - 1
  init_bin = [int(x) for x in bin(int_val & one_bits)[2:]]
  sign_ext = [0]*(bits-len(init_bin))
  binary = sign_ext + init_bin
  return binary

def binarr2int(bin_arr):
  out = 0
  if(bin_arr[0] == 0):
    for bit in bin_arr[1:]:
      out = (out << 1) | bit
    return out
  else:
    for bit in bin_arr[1:]:
      out = (out << 1) | (not bit)
    return -1*(out + 1)


def initPop(dim, pop_size, ran):
    pop = np.random.randint(-2**ran, 2**ran, size=(pop_size, dim))
    return pop

# def PoptoBin(pop):
#   popbin = []
#   for i in range(pop.shape[0]):
#     Pi = []
#     for j in range(pop.shape[1]):
#       Xi_bin = int2binarr(pop[i][j], bits)
#       Pi.append(Xi_bin)
#     popbin.append(Pi)   
#   popbin = np.asarray(popbin)
#   return popbin

# def BintoPop(popbin):
#   pop = []
#   for i in range(popbin.shape[0]):
#     Pi = []
#     for j in range(popbin.shape[1]):
#       Xi = binarr2int(popbin[i][j])
#       Pi.append(Xi)
#     pop.append(Pi)   
#   pop = np.asarray(pop)
#   return pop

def crossover(index1, index2, pc, pop):

  prob = rand.uniform(0,1)
  if prob > pc:
    # No Crossover done
    return pop
  else:
    # Implement Crossover 
    for i in range(pop.shape[1]):
      gen1 = int2binarr(pop[index1][i], bits) # Binary array of Parent 1
      gen2 = int2binarr(pop[index2][i], bits) # Binary array of Parent 2

      pos = rand.randint(1,bits)  # Position of crosssover
      child1 = gen2[0:pos] + gen1[pos:] # Binary array of Child 1
      child2 = gen1[0:pos] + gen2[pos:] # Binary array of Child 2

      pop[index1][i] = binarr2int(child1)
      pop[index2][i] = binarr2int(child2)
    return pop

def mutation(pop, pm):
  for i in range(pop.shape[0]):
    prob1 = rand.uniform(0,1)
    if prob1 < pm:
      for j in range(pop.shape[1]):
        gen = int2binarr(pop[i][j], bits)
        for z in range(bits):
          prob2 = rand.uniform(0,1)
          if prob2 < pm:
            gen[z] = int(not gen[z])
        pop[i][j] = binarr2int(gen)
  return pop

## Hard coded params (During development use)
A = [[-1,0],[0,-1]]
b = [[2],[2]]
c = 1
pop_size = 500
dim = 2
ran = 5
iter = 200
bits = ran + 1
pc = 0.8
pm = 0.1

def GA(iter):
  pop = initPop(dim, pop_size, ran) #initialize population
  fitness = popFitness(pop) #find fitness of population
   
  for i in range(iter):
    # FIFO Replacement
    repl_num = int(pop.shape[0]*0.8)
    reqIdx = roulette(pop, repl_num) #Roulette Wheel scaling
    for idx in reqIdx:
      pop = np.append(pop,[pop[idx]],axis=0) 
    pop = pop[repl_num:] 

    index1 = roulette(pop,1) #parent selection
    index2 = roulette(pop,1)

    pop = crossover(index1[0], index2[0], pc, pop) #crossover with probability pc
    pop = mutation(pop, pm) #mutation with probability pm

  fitness = popFitness(pop) #decode and fitness calculation
  best = max(fitness) #find best
  best_idx = fitness.index(best) 
  bestX = pop[best_idx]   

  return pop, fitness, best, bestX

## Run This for Final output

# A, b, c = getfunc()
# pop_size, pc, pm, iter, ran = getAlgoParam()
# bits = ran + 1
# dim = len(A[0])

pop, fitness, best, bestX = GA(iter)
print("Final Population:")
print(pop)
print("Final Target Fun values:")
print(fitness)
print("Max Fun value: ", best)
print("Integers for Max value: ", bestX)